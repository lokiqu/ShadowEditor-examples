{"Code":200,"Msg":"获取成功！","Data":[{"_id":"5bba012bc8b49e43947f5b35","metadata":{"generator":"OptionsSerializer","type":"Object","version":"0.0.1"},"server":"http://localhost:2000","theme":"assets/css/light.css","showGrid":false,"showCameraHelper":true,"showPointLightHelper":false,"showDirectionalLightHelper":false,"showSpotLightHelper":true,"showHemisphereLightHelper":true,"showRectAreaLightHelper":true,"showSkeletonHelper":false},{"_id":"5bba012bc8b49e43947f5b36","metadata":{"generator":"PerspectiveCameraSerializer","type":"Object","version":"0.0.1"},"castShadow":false,"children":["CA9ABF0F-EDC1-4002-ACB7-A82041F8CEBD"],"frustumCulled":true,"layers":{"mask":1},"matrix":{"elements":[0.9987302813516723,1.7347234759768071E-18,-0.050376831095351175,0,-0.017974299331654613,0.9341819637965445,-0.35634391124413467,0,0.047061127002501986,0.35679694297629805,0.93299581553618061,0,9.6612215683398652,38.071360812452951,170.91976416780179,1]},"matrixAutoUpdate":true,"matrixWorld":{"elements":[0.9987302813516723,1.7347234759768071E-18,-0.050376831095351175,0,-0.017974299331654613,0.9341819637965445,-0.35634391124413467,0,0.047061127002501986,0.35679694297629805,0.93299581553618061,0,9.6612215683398652,38.071360812452951,170.91976416780179,1]},"matrixWorldNeedsUpdate":false,"modelViewMatrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"name":"默认相机","normalMatrix":{"elements":[1,0,0,0,1,0,0,0,1]},"parent":null,"position":{"x":9.6612215683398652,"y":38.071360812452951,"z":170.91976416780179},"quaternion":{"x":-0.1813508354122936,"y":0.024778351986621382,"z":0.00457084204397387,"w":0.98309562870104317},"receiveShadow":false,"renderOrder":0,"rotation":{"x":-0.3652605929765349,"y":0.047078515774335875,"z":0.017995207950021672,"order":"XYZ"},"scale":{"x":1,"y":1,"z":1},"type":"PerspectiveCamera","up":{"x":0,"y":1,"z":0},"userData":{"isDefault":true},"uuid":"67748092-2892-4A65-B65C-E632129C7CEB","visible":true,"isObject3D":true,"matrixWorldInverse":{"elements":[0.9987302813516723,-0.017974299331654613,0.047061127002501986,0,3.4694469519536142E-18,0.93418196379654461,0.35679694297629805,0,-0.050376831095351182,-0.35634391124413473,0.93299581553618061,0,-1.0385584448103131,25.514292352674275,-173.50583788904771,1]},"projectionMatrix":{"elements":[0.99587786462210648,0,0,0,0,2.1445069205095586,0,0,0,0,-1.0000200002000021,-1,0,0,-0.20000200002000021,0]},"aspect":2.1533834586466165,"far":10000,"filmGauge":35,"filmOffset":0,"focus":10,"fov":50,"near":0.1,"view":null,"zoom":1},{"_id":"5bba012bc8b49e43947f5b37","metadata":{"generator":"WebGLRendererSerializer","type":"Object","version":"0.0.1"},"antialias":true,"autoClear":false,"autoClearColor":true,"autoClearDepth":true,"autoClearStencil":true,"autoUpdateScene":false,"clippingPlanes":[],"gammaFactor":2,"gammaInput":false,"gammaOutput":false,"localClippingEnabled":false,"physicallyCorrectLights":false,"shadowMap":{"metadata":{"generator":"WebGLShadowMapSerializer","type":"Object","version":"0.0.1"},"autoUpdate":true,"enabled":true,"needsUpdate":false,"type":2},"sortObjects":true,"toneMapping":1,"toneMappingExposure":1,"toneMappingWhitePoint":1},{"_id":"5bba012bc8b49e43947f5b38","metadata":{"generator":"AnimationSerializer","type":"Object","version":"0.0.1"},"id":null,"uuid":"8E9F4155-0264-4F63-9E1F-A9A14C7166D7","name":"组1","type":"AnimationGroup","index":1,"animations":[]},{"_id":"5bba012bc8b49e43947f5b39","metadata":{"generator":"AnimationSerializer","type":"Object","version":"0.0.1"},"id":null,"uuid":"D91F9424-0EF1-41CB-9A38-4531598C95DC","name":"组2","type":"AnimationGroup","index":1,"animations":[]},{"_id":"5bba012bc8b49e43947f5b3a","metadata":{"generator":"AnimationSerializer","type":"Object","version":"0.0.1"},"id":null,"uuid":"CAA2240B-6CCC-4DD2-8CBF-1569E743A6C4","name":"组3","type":"AnimationGroup","index":2,"animations":[]},{"_id":"5bba012bc8b49e43947f5b3b","metadata":{"generator":"AudioListenerSerializer","type":"Object","version":"0.0.1"},"castShadow":false,"children":[],"frustumCulled":true,"layers":{"mask":1},"matrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"matrixAutoUpdate":true,"matrixWorld":{"elements":[0.9987302813516723,1.7347234759768071E-18,-0.050376831095351175,0,-0.017974299331654613,0.9341819637965445,-0.35634391124413467,0,0.047061127002501986,0.35679694297629805,0.93299581553618061,0,9.6612215683398652,38.071360812452951,170.91976416780179,1]},"matrixWorldNeedsUpdate":false,"modelViewMatrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"name":"音频监听器","normalMatrix":{"elements":[1,0,0,0,1,0,0,0,1]},"parent":"67748092-2892-4A65-B65C-E632129C7CEB","position":{"x":0,"y":0,"z":0},"quaternion":{"x":0,"y":0,"z":0,"w":1},"receiveShadow":false,"renderOrder":0,"rotation":{"x":0,"y":0,"z":0,"order":"XYZ"},"scale":{"x":1,"y":1,"z":1},"type":"AudioListener","up":{"x":0,"y":1,"z":0},"userData":{},"uuid":"CA9ABF0F-EDC1-4002-ACB7-A82041F8CEBD","visible":true,"isObject3D":true,"masterVolume":1},{"_id":"5bba012bc8b49e43947f5b3c","metadata":{"generator":"SceneSerializer","type":"Object","version":"0.0.1"},"castShadow":false,"children":["A2788B85-C53B-4FDF-BC11-6363CD792260","A8FBE3F2-D4ED-4F8B-A919-2FCC7FC12906","9108DB20-FF3E-4F27-8AED-0A346AC34FB6","7BB96BAD-38DB-4B57-8210-C9B4230A9C3A"],"frustumCulled":true,"layers":{"mask":1},"matrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"matrixAutoUpdate":true,"matrixWorld":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"matrixWorldNeedsUpdate":false,"modelViewMatrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"name":"场景","normalMatrix":{"elements":[1,0,0,0,1,0,0,0,1]},"parent":null,"position":{"x":0,"y":0,"z":0},"quaternion":{"x":0,"y":0,"z":0,"w":1},"receiveShadow":false,"renderOrder":0,"rotation":{"x":0,"y":0,"z":0,"order":"XYZ"},"scale":{"x":1,"y":1,"z":1},"type":"Scene","up":{"x":0,"y":1,"z":0},"userData":{},"uuid":"9450DB8E-65E4-4B21-BF87-10748E9A3E1C","visible":true,"isObject3D":true,"background":11184810,"fog":null,"overrideMaterial":null},{"_id":"5bba012bc8b49e43947f5b3d","metadata":{"generator":"AmbientLightSerializer","type":"Object","version":"0.0.1"},"children":[],"frustumCulled":true,"layers":{"mask":1},"matrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"matrixAutoUpdate":true,"matrixWorld":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"matrixWorldNeedsUpdate":false,"modelViewMatrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"name":"环境光","normalMatrix":{"elements":[1,0,0,0,1,0,0,0,1]},"parent":"9450DB8E-65E4-4B21-BF87-10748E9A3E1C","position":{"x":0,"y":0,"z":0},"quaternion":{"x":0,"y":0,"z":0,"w":1},"renderOrder":0,"rotation":{"x":0,"y":0,"z":0,"order":"XYZ"},"scale":{"x":1,"y":1,"z":1},"type":"AmbientLight","up":{"x":0,"y":1,"z":0},"userData":{},"uuid":"A2788B85-C53B-4FDF-BC11-6363CD792260","visible":true,"isObject3D":true,"color":16777215,"intensity":1.29,"isLight":true,"shadow":null,"isAmbientLight":true},{"_id":"5bba012bc8b49e43947f5b3e","metadata":{"generator":"DirectionalLightSerializer","type":"Object","version":"0.0.1"},"castShadow":true,"children":[],"frustumCulled":true,"layers":{"mask":1},"matrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,5,10,7.5,1]},"matrixAutoUpdate":true,"matrixWorld":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,5,10,7.5,1]},"matrixWorldNeedsUpdate":false,"modelViewMatrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"name":"平行光","normalMatrix":{"elements":[1,0,0,0,1,0,0,0,1]},"parent":"9450DB8E-65E4-4B21-BF87-10748E9A3E1C","position":{"x":5,"y":10,"z":7.5},"quaternion":{"x":0,"y":0,"z":0,"w":1},"renderOrder":0,"rotation":{"x":0,"y":0,"z":0,"order":"XYZ"},"scale":{"x":1,"y":1,"z":1},"type":"DirectionalLight","up":{"x":0,"y":1,"z":0},"userData":{},"uuid":"A8FBE3F2-D4ED-4F8B-A919-2FCC7FC12906","visible":true,"isObject3D":true,"color":16777215,"intensity":1.07,"isLight":true,"shadow":{"metadata":{"generator":"DirectionalLightShadowSerializer","type":"Object","version":"0.0.1"},"bias":0,"camera":{"metadata":{"generator":"OrthographicCameraSerializer","type":"Object","version":"0.0.1"},"castShadow":false,"children":[],"frustumCulled":true,"layers":{"mask":1},"matrix":{"elements":[0.83205029433784372,2.7755575615628914E-17,-0.554700196225229,0,-0.41202096209968375,0.66953406341198618,-0.61803144314952574,0,0.37139067635410372,0.74278135270820744,0.55708601453115558,0,5,10,7.5,1]},"matrixAutoUpdate":true,"matrixWorld":{"elements":[0.83205029433784372,2.7755575615628914E-17,-0.554700196225229,0,-0.41202096209968375,0.66953406341198618,-0.61803144314952574,0,0.37139067635410372,0.74278135270820744,0.55708601453115558,0,5,10,7.5,1]},"matrixWorldNeedsUpdate":false,"modelViewMatrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"name":"","normalMatrix":{"elements":[1,0,0,0,1,0,0,0,1]},"parent":null,"position":{"x":5,"y":10,"z":7.5},"quaternion":{"x":-0.38904698186552672,"y":0.26476298577359092,"z":0.1177939480420426,"w":0.87445273918619892},"receiveShadow":false,"renderOrder":0,"rotation":{"x":-0.92729521800161219,"y":0.3805063771123649,"z":0.45979025757734426,"order":"XYZ"},"scale":{"x":1,"y":1,"z":1},"type":"OrthographicCamera","up":{"x":0,"y":1,"z":0},"userData":{},"uuid":"B1A6A252-9F06-440B-8164-2BDA4E9474D7","visible":true,"isObject3D":true,"matrixWorldInverse":{"elements":[0.83205029433784372,-0.41202096209968375,0.37139067635410367,0,-5.5511151231257827E-17,0.66953406341198618,0.74278135270820744,0,-0.55470019622522915,-0.61803144314952574,0.55708601453115558,0,0,0,-13.46291201783626,1]},"projectionMatrix":{"elements":[0.01,0,0,0,0,0.01,0,0,0,0,-0.004004004004004004,0,0,0,-1.002002002002002,1]},"bottom":-100,"far":500,"left":-100,"near":0.5,"right":100,"top":100,"view":null,"zoom":1},"map":{"metadata":{"generator":"WebGLRenderTargetSerializer","type":"Object","version":"0.0.1"},"depthBuffer":true,"depthTexture":null,"height":2048,"scissor":{"x":0,"y":0,"z":2048,"w":2048},"scissorTest":false,"stencilBuffer":true,"texture":{"metadata":{"generator":"TextureSerializer","type":"Object","version":"0.0.1"},"anisotropy":1,"center":{"x":0,"y":0},"encoding":3000,"flipY":true,"format":1023,"generateMipmaps":true,"image":null,"magFilter":1003,"mapping":300,"matrix":{"elements":[1,0,0,0,1,0,0,0,1]},"matrixAutoUpdate":true,"minFilter":1003,"mipmaps":[],"name":"平行光.shadowMap","offset":{"x":0,"y":0},"premultiplyAlpha":false,"repeat":{"x":1,"y":1},"rotation":0,"type":1009,"unpackAlignment":4,"uuid":"ABA2E5D4-A492-4DF9-AC47-619C5B549E78","version":0,"wrapS":1001,"wrapT":1001,"isTexture":true},"viewport":{"x":0,"y":0,"z":2048,"w":2048},"width":2048,"isWebGLRenderTarget":true},"mapSize":{"x":2048,"y":2048},"matrix":{"elements":[0.0041602514716892183,-0.0020601048104984189,-0.00074352487758579317,0,-2.7755575615628914E-19,0.0033476703170599309,-0.0014870497551715866,0,-0.002773500981126146,-0.0030901572157476286,-0.00111528731637869,0,0.5,0.5,0.025951775811484026,1]},"radius":1},"isDirectionalLight":true},{"_id":"5bba012bc8b49e43947f5b3f","metadata":{"generator":"MeshSerializer","type":"Object","version":"0.0.1"},"castShadow":false,"children":[],"frustumCulled":true,"layers":{"mask":1},"matrix":{"elements":[450000,0,0,0,0,450000,0,0,0,0,450000,0,0,0,0,1]},"matrixAutoUpdate":true,"matrixWorld":{"elements":[450000,0,0,0,0,450000,0,0,0,0,450000,0,0,0,0,1]},"matrixWorldNeedsUpdate":false,"modelViewMatrix":{"elements":[449428.62660825253,-8088.4346992445753,21177.507151125894,0,1.5612511283791264E-12,420381.88370844506,160558.62433933411,0,-22669.573992908034,-160354.76005986062,419848.11699128128,0,-1.0385584448103131,25.514292352674275,-173.50583788904771,1]},"name":"","normalMatrix":{"elements":[2.2194006252259383E-06,-3.994288740367692E-08,1.045802822277822E-07,5.2327808856310007E-24,2.0759599195478762E-06,7.9288209550288454E-07,-1.1194851354522482E-07,-7.9187535832029912E-07,2.0733240345248456E-06]},"parent":"9108DB20-FF3E-4F27-8AED-0A346AC34FB6","position":{"x":0,"y":0,"z":0},"quaternion":{"x":0,"y":0,"z":0,"w":1},"receiveShadow":false,"renderOrder":0,"rotation":{"x":0,"y":0,"z":0,"order":"XYZ"},"scale":{"x":450000,"y":450000,"z":450000},"type":"Mesh","up":{"x":0,"y":1,"z":0},"userData":{},"uuid":"FF8E2244-7514-4D6E-A274-A07314DA9B0B","visible":true,"isObject3D":true,"drawMode":0,"geometry":{"metadata":{"generator":"BoxBufferGeometrySerializer","type":"Object","version":"0.0.1"},"boundingBox":null,"boundingSphere":{"center":{"x":0,"y":0,"z":0},"radius":0.8660254037844386},"drawRange":{"start":0,"count":null},"groups":[{"start":0,"count":6,"materialIndex":0},{"start":6,"count":6,"materialIndex":1},{"start":12,"count":6,"materialIndex":2},{"start":18,"count":6,"materialIndex":3},{"start":24,"count":6,"materialIndex":4},{"start":30,"count":6,"materialIndex":5}],"morphAttributes":{},"name":"","parameters":{"width":1,"height":1,"depth":1},"type":"BoxBufferGeometry","userData":{},"uuid":"7D42BA02-FEE0-427D-9E3B-F18B4641884F"},"material":{"metadata":{"generator":"ShaderMaterialSerializer","type":"Object","version":"0.0.1"},"alphaMap":null,"alphaTest":0,"aoMap":null,"blendDst":205,"blendDstAlpha":null,"blendEquation":100,"blendEquationAlpha":null,"blendSrc":204,"blendSrcAlpha":null,"blending":1,"bumpMap":null,"clipIntersection":false,"clippingPlanes":null,"colorWrite":true,"depthFunc":3,"depthTest":true,"depthWrite":true,"displacementMap":null,"dithering":false,"emissiveMap":null,"envMap":null,"flatShading":false,"fog":false,"lightMap":null,"lights":false,"linewidth":1,"map":null,"metalnessMap":null,"morphNormals":false,"morphTargets":false,"name":"","normalMap":null,"opacity":1,"overdraw":0,"polygonOffset":false,"polygonOffsetFactor":0,"polygonOffsetUnits":0,"precision":null,"premultipliedAlpha":false,"roughnessMap":null,"shadowSide":null,"side":1,"skinning":false,"transparent":false,"type":"ShaderMaterial","userData":{},"uuid":"0A6A597F-34ED-4D41-97D4-F6BFF63CD007","vertexColors":0,"visible":true,"wireframe":false,"wireframeLinewidth":1,"defines":{},"uniforms":{"luminance":{"value":1},"turbidity":{"value":10},"rayleigh":{"value":2},"mieCoefficient":{"value":0.005},"mieDirectionalG":{"value":0.8},"sunPosition":{"value":{"x":2.4492935982947064E-11,"y":12564.303631251329,"z":-399802.62414629263}}},"vertexShader":"uniform vec3 sunPosition;\nuniform float rayleigh;\nuniform float turbidity;\nuniform float mieCoefficient;\nvarying vec3 vWorldPosition;\nvarying vec3 vSunDirection;\nvarying float vSunfade;\nvarying vec3 vBetaR;\nvarying vec3 vBetaM;\nvarying float vSunE;\nconst vec3 up = vec3( 0.0, 1.0, 0.0 );\nconst float e = 2.71828182845904523536028747135266249775724709369995957;\nconst float pi = 3.141592653589793238462643383279502884197169;\nconst vec3 lambda = vec3( 680E-9, 550E-9, 450E-9 );\nconst vec3 totalRayleigh = vec3( 5.804542996261093E-6, 1.3562911419845635E-5, 3.0265902468824876E-5 );\nconst float v = 4.0;\nconst vec3 K = vec3( 0.686, 0.678, 0.666 );\nconst vec3 MieConst = vec3( 1.8399918514433978E14, 2.7798023919660528E14, 4.0790479543861094E14 );\nconst float cutoffAngle = 1.6110731556870734;\nconst float steepness = 1.5;\nconst float EE = 1000.0;\nfloat sunIntensity( float zenithAngleCos ) {\n\tzenithAngleCos = clamp( zenithAngleCos, -1.0, 1.0 );\n\treturn EE * max( 0.0, 1.0 - pow( e, -( ( cutoffAngle - acos( zenithAngleCos ) ) / steepness ) ) );\n}\nvec3 totalMie( float T ) {\n\tfloat c = ( 0.2 * T ) * 10E-18;\n\treturn 0.434 * c * MieConst;\n}\nvoid main() {\n\tvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\n\tvWorldPosition = worldPosition.xyz;\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position.z = gl_Position.w;\n\tvSunDirection = normalize( sunPosition );\n\tvSunE = sunIntensity( dot( vSunDirection, up ) );\n\tvSunfade = 1.0 - clamp( 1.0 - exp( ( sunPosition.y / 450000.0 ) ), 0.0, 1.0 );\n\tfloat rayleighCoefficient = rayleigh - ( 1.0 * ( 1.0 - vSunfade ) );\n\tvBetaR = totalRayleigh * rayleighCoefficient;\n\tvBetaM = totalMie( turbidity ) * mieCoefficient;\n}","fragmentShader":"varying vec3 vWorldPosition;\nvarying vec3 vSunDirection;\nvarying float vSunfade;\nvarying vec3 vBetaR;\nvarying vec3 vBetaM;\nvarying float vSunE;\nuniform float luminance;\nuniform float mieDirectionalG;\nconst vec3 cameraPos = vec3( 0.0, 0.0, 0.0 );\nconst float pi = 3.141592653589793238462643383279502884197169;\nconst float n = 1.0003;\nconst float N = 2.545E25;\nconst float rayleighZenithLength = 8.4E3;\nconst float mieZenithLength = 1.25E3;\nconst vec3 up = vec3( 0.0, 1.0, 0.0 );\nconst float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;\nconst float THREE_OVER_SIXTEENPI = 0.05968310365946075;\nconst float ONE_OVER_FOURPI = 0.07957747154594767;\nfloat rayleighPhase( float cosTheta ) {\n\treturn THREE_OVER_SIXTEENPI * ( 1.0 + pow( cosTheta, 2.0 ) );\n}\nfloat hgPhase( float cosTheta, float g ) {\n\tfloat g2 = pow( g, 2.0 );\n\tfloat inverse = 1.0 / pow( 1.0 - 2.0 * g * cosTheta + g2, 1.5 );\n\treturn ONE_OVER_FOURPI * ( ( 1.0 - g2 ) * inverse );\n}\nconst float A = 0.15;\nconst float B = 0.50;\nconst float C = 0.10;\nconst float D = 0.20;\nconst float E = 0.02;\nconst float F = 0.30;\nconst float whiteScale = 1.0748724675633854;\nvec3 Uncharted2Tonemap( vec3 x ) {\n\treturn ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;\n}\nvoid main() {\n\tfloat zenithAngle = acos( max( 0.0, dot( up, normalize( vWorldPosition - cameraPos ) ) ) );\n\tfloat inverse = 1.0 / ( cos( zenithAngle ) + 0.15 * pow( 93.885 - ( ( zenithAngle * 180.0 ) / pi ), -1.253 ) );\n\tfloat sR = rayleighZenithLength * inverse;\n\tfloat sM = mieZenithLength * inverse;\n\tvec3 Fex = exp( -( vBetaR * sR + vBetaM * sM ) );\n\tfloat cosTheta = dot( normalize( vWorldPosition - cameraPos ), vSunDirection );\n\tfloat rPhase = rayleighPhase( cosTheta * 0.5 + 0.5 );\n\tvec3 betaRTheta = vBetaR * rPhase;\n\tfloat mPhase = hgPhase( cosTheta, mieDirectionalG );\n\tvec3 betaMTheta = vBetaM * mPhase;\n\tvec3 Lin = pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * ( 1.0 - Fex ), vec3( 1.5 ) );\n\tLin *= mix( vec3( 1.0 ), pow( vSunE * ( ( betaRTheta + betaMTheta ) / ( vBetaR + vBetaM ) ) * Fex, vec3( 1.0 / 2.0 ) ), clamp( pow( 1.0 - dot( up, vSunDirection ), 5.0 ), 0.0, 1.0 ) );\n\tvec3 direction = normalize( vWorldPosition - cameraPos );\n\tfloat theta = acos( direction.y ); // elevation --> y-axis, [-pi/2, pi/2]\n\tfloat phi = atan( direction.z, direction.x ); // azimuth --> x-axis [-pi/2, pi/2]\n\tvec2 uv = vec2( phi, theta ) / vec2( 2.0 * pi, pi ) + vec2( 0.5, 0.0 );\n\tvec3 L0 = vec3( 0.1 ) * Fex;\n\tfloat sundisk = smoothstep( sunAngularDiameterCos, sunAngularDiameterCos + 0.00002, cosTheta );\n\tL0 += ( vSunE * 19000.0 * Fex ) * sundisk;\n\tvec3 texColor = ( Lin + L0 ) * 0.04 + vec3( 0.0, 0.0003, 0.00075 );\n\tvec3 curr = Uncharted2Tonemap( ( log2( 2.0 / pow( luminance, 4.0 ) ) ) * texColor );\n\tvec3 color = curr * whiteScale;\n\tvec3 retColor = pow( color, vec3( 1.0 / ( 1.2 + ( 1.2 * vSunfade ) ) ) );\n\tgl_FragColor = vec4( retColor, 1.0 );\n}"}},{"_id":"5bba012bc8b49e43947f5b40","metadata":{"generator":"MeshSerializer","type":"Object","version":"0.0.1"},"castShadow":false,"children":[],"frustumCulled":true,"layers":{"mask":1},"matrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,2.4492935982947064E-11,12564.303631251329,-399802.62414629263,1]},"matrixAutoUpdate":true,"matrixWorld":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,2.4492935982947064E-11,12564.303631251329,-399802.62414629263,1]},"matrixWorldNeedsUpdate":false,"modelViewMatrix":{"elements":[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]},"name":"","normalMatrix":{"elements":[1,0,0,0,1,0,0,0,1]},"parent":"9108DB20-FF3E-4F27-8AED-0A346AC34FB6","position":{"x":2.4492935982947064E-11,"y":12564.303631251329,"z":-399802.62414629263},"quaternion":{"x":0,"y":0,"z":0,"w":1},"receiveShadow":false,"renderOrder":0,"rotation":{"x":0,"y":0,"z":0,"order":"XYZ"},"scale":{"x":1,"y":1,"z":1},"type":"Mesh","up":{"x":0,"y":1,"z":0},"userData":{},"uuid":"3DCE6616-2772-447D-A6EA-482CA505DC7F","visible":true,"isObject3D":true,"drawMode":0,"geometry":{"metadata":{"generator":"SphereBufferGeometrySerializer","type":"Object","version":"0.0.1"},"boundingBox":null,"boundingSphere":{"center":{"x":0,"y":0,"z":0},"radius":20000.000415455586},"drawRange":{"start":0,"count":null},"groups":[],"morphAttributes":{},"name":"","parameters":{"radius":20000,"widthSegments":16,"heightSegments":8},"type":"SphereBufferGeometry","userData":{},"uuid":"F9AAD61B-1C11-46C6-B068-302070751197"},"material":{"metadata":{"generator":"MeshBasicMaterialSerializer","type":"Object","version":"0.0.1"},"alphaMap":null,"alphaTest":0,"aoMap":null,"aoMapIntensity":1,"blendDst":205,"blendDstAlpha":null,"blendEquation":100,"blendEquationAlpha":null,"blendSrc":204,"blendSrcAlpha":null,"blending":1,"bumpMap":null,"clipIntersection":false,"clippingPlanes":null,"color":16777215,"colorWrite":true,"depthFunc":3,"depthTest":true,"depthWrite":true,"displacementMap":null,"dithering":false,"emissiveMap":null,"envMap":null,"flatShading":false,"fog":true,"lightMap":null,"lightMapIntensity":1,"lights":false,"map":null,"metalnessMap":null,"morphTargets":false,"name":"","normalMap":null,"opacity":1,"overdraw":0,"polygonOffset":false,"polygonOffsetFactor":0,"polygonOffsetUnits":0,"precision":null,"premultipliedAlpha":false,"refractionRatio":0.98,"roughnessMap":null,"shadowSide":null,"side":0,"skinning":false,"transparent":false,"type":"MeshBasicMaterial","userData":{},"uuid":"F3A223F7-CF14-4DEA-9151-8B7B3B848A6E","vertexColors":0,"visible":true,"wireframe":false,"wireframeLinecap":"round","wireframeLinejoin":"round","wireframeLinewidth":1}},{"_id":"5bba012bc8b49e43947f5b41","metadata":{"generator":"MeshSerializer","type":"Object","version":"0.0.1"},"castShadow":false,"children":[],"frustumCulled":true,"layers":{"mask":1},"matrix":{"elements":[0.1,0,0,0,0,2.2204460492503132E-17,-0.1,0,0,0.1,2.2204460492503132E-17,0,0,-30,0,1]},"matrixAutoUpdate":true,"matrixWorld":{"elements":[0.1,0,0,0,0,2.2204460492503132E-17,-0.1,0,0,0.1,2.2204460492503132E-17,0,0,-30,0,1]},"matrixWorldNeedsUpdate":false,"modelViewMatrix":{"elements":[0.099873028135167241,-0.0017974299331654613,0.0047061127002501991,0,0.0050376831095351182,0.035634391124413495,-0.093299581553618047,0,-7.7164566059886711E-19,0.093418196379654456,0.035679694297629828,0,-1.0385584448103131,-2.5111665612220619,-184.20974617833664,1]},"name":"地形","normalMatrix":{"elements":[9.9873028135167221,-0.17974299331654614,0.47061127002501996,0.50376831095351182,3.5634391124413489,-9.3299581553618065,-1.3552527156068803E-16,9.3418196379654432,3.5679694297629823]},"parent":"9450DB8E-65E4-4B21-BF87-10748E9A3E1C","position":{"x":0,"y":-30,"z":0},"quaternion":{"x":-0.70710678118654746,"y":0,"z":0,"w":0.70710678118654757},"receiveShadow":false,"renderOrder":0,"rotation":{"x":-1.5707963267948966,"y":0,"z":0,"order":"XYZ"},"scale":{"x":0.1,"y":0.1,"z":0.1},"type":"Mesh","up":{"x":0,"y":1,"z":0},"userData":{},"uuid":"7BB96BAD-38DB-4B57-8210-C9B4230A9C3A","visible":true,"isObject3D":true,"drawMode":0,"geometry":{"metadata":{"generator":"PlaneBufferGeometrySerializer","type":"Object","version":"0.0.1"},"boundingBox":null,"boundingSphere":{"center":{"x":0,"y":0,"z":0},"radius":4242.6406871192848},"drawRange":{"start":0,"count":null},"groups":[],"morphAttributes":{},"name":"","parameters":{"width":6000,"height":6000,"widthSegments":256,"heightSegments":256},"type":"PlaneBufferGeometry","userData":{},"uuid":"F257C600-74C2-4899-A7B9-1CC9FBFCD7B6"},"material":{"metadata":{"generator":"ShaderMaterialSerializer","type":"Object","version":"0.0.1"},"alphaMap":null,"alphaTest":0,"aoMap":null,"blendDst":205,"blendDstAlpha":null,"blendEquation":100,"blendEquationAlpha":null,"blendSrc":204,"blendSrcAlpha":null,"blending":1,"bumpMap":null,"clipIntersection":false,"clippingPlanes":null,"colorWrite":true,"depthFunc":3,"depthTest":true,"depthWrite":true,"displacementMap":null,"dithering":false,"emissiveMap":null,"envMap":null,"flatShading":false,"fog":true,"lightMap":null,"lights":true,"linewidth":1,"map":null,"metalnessMap":null,"morphNormals":false,"morphTargets":false,"name":"","normalMap":null,"opacity":1,"overdraw":0,"polygonOffset":false,"polygonOffsetFactor":0,"polygonOffsetUnits":0,"precision":null,"premultipliedAlpha":false,"roughnessMap":null,"shadowSide":null,"side":0,"skinning":false,"transparent":false,"type":"ShaderMaterial","userData":{},"uuid":"254484D4-6426-4F0B-A7EB-EA8F900B81BC","vertexColors":0,"visible":true,"wireframe":false,"wireframeLinewidth":1,"defines":{},"uniforms":{"fogDensity":{"value":0.00025},"fogNear":{"value":1},"fogFar":{"value":2000},"fogColor":{"type":"color","value":16777215},"ambientLightColor":{"value":[1.29,1.29,1.29]},"directionalLights":{"value":[{"direction":{"x":0.3428548866269035,"y":0.488703246241194,"z":0.80225910018482938},"color":17895696,"shadow":true,"shadowBias":0,"shadowRadius":1,"shadowMapSize":{"x":2048,"y":2048}}]},"directionalShadowMap":{"value":[{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"ABA2E5D4-A492-4DF9-AC47-619C5B549E78","name":"平行光.shadowMap","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1001,1001],"format":1023,"minFilter":1003,"magFilter":1003,"anisotropy":1,"flipY":true}]},"directionalShadowMatrix":{"value":[{"elements":[0.0041602514716892183,-0.0020601048104984189,-0.00074352487758579317,0,-2.7755575615628914E-19,0.0033476703170599309,-0.0014870497551715866,0,-0.002773500981126146,-0.0030901572157476286,-0.00111528731637869,0,0.5,0.5,0.025951775811484026,1]}]},"spotLights":{"value":[]},"spotShadowMap":{"value":[]},"spotShadowMatrix":{"value":[]},"pointLights":{"value":[]},"pointShadowMap":{"value":[]},"pointShadowMatrix":{"value":[]},"hemisphereLights":{"value":[]},"rectAreaLights":{"value":[]},"enableDiffuse1":{"value":true},"enableDiffuse2":{"value":true},"enableSpecular":{"value":true},"enableReflection":{"value":0},"tDiffuse1":{"value":{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"6CF0FA4D-2160-4F2E-8B56-F0129F882D33","name":"","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1000,1000],"format":1022,"minFilter":1008,"magFilter":1006,"anisotropy":1,"flipY":true,"image":"77233440-659D-4BD0-83B4-ACA93C0343B5"}},"tDiffuse2":{"value":{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"DF3F9A0B-4991-488F-9DE7-0770EE7F2CC7","name":"","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1000,1000],"format":1022,"minFilter":1008,"magFilter":1006,"anisotropy":1,"flipY":true,"image":"4C00D255-9D28-42D2-B15A-687F64435CFD"}},"tDetail":{"value":{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"ADDB2034-7BAA-45AA-AB04-0FD16FCA1D70","name":"","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1000,1000],"format":1022,"minFilter":1008,"magFilter":1006,"anisotropy":1,"flipY":true,"image":"2A7C3E74-116C-446D-AFA0-A6D2FF3AC9E4"}},"tNormal":{"value":{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"AB533F05-4481-4A39-A3B5-B6FE5B252713","name":"","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1001,1001],"format":1022,"minFilter":1006,"magFilter":1006,"anisotropy":1,"flipY":true}},"tSpecular":{"value":{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"45B4B6C1-D052-473E-90DE-E30AB25AC42B","name":"","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1001,1001],"format":1022,"minFilter":1006,"magFilter":1006,"anisotropy":1,"flipY":true}},"tDisplacement":{"value":{"metadata":{"version":4.5,"type":"Texture","generator":"Texture.toJSON"},"uuid":"A244A48B-DE0F-4845-AFB4-AAF42C4D66F1","name":"","mapping":300,"repeat":[1,1],"offset":[0,0],"center":[0,0],"rotation":0,"wrap":[1001,1001],"format":1022,"minFilter":1006,"magFilter":1006,"anisotropy":1,"flipY":true}},"uNormalScale":{"value":null},"uDisplacementBias":{"value":0},"uDisplacementScale":{"value":375},"diffuse":{"type":"color","value":16777215},"specular":{"type":"color","value":16777215},"shininess":{"value":30},"opacity":{"value":1},"uRepeatBase":{"value":{"x":1,"y":1}},"uRepeatOverlay":{"value":{"x":6,"y":6}},"uOffset":{"value":{"x":0,"y":0}}},"vertexShader":"attribute vec4 tangent;\nuniform vec2 uRepeatBase;\nuniform sampler2D tNormal;\n#ifdef VERTEX_TEXTURES\nuniform sampler2D tDisplacement;\nuniform float uDisplacementScale;\nuniform float uDisplacementBias;\n#endif\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vViewPosition;\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n\n#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n\nvoid main() {\nvNormal = normalize( normalMatrix * normal );\nvTangent = normalize( normalMatrix * tangent.xyz );\nvBinormal = cross( vNormal, vTangent ) * tangent.w;\nvBinormal = normalize( vBinormal );\nvUv = uv;\nvec2 uvBase = uv * uRepeatBase;\n#ifdef VERTEX_TEXTURES\nvec3 dv = texture2D( tDisplacement, uvBase ).xyz;\nfloat df = uDisplacementScale * dv.x + uDisplacementBias;\nvec3 displacedPosition = normal * df + position;\nvec4 worldPosition = modelMatrix * vec4( displacedPosition, 1.0 );\nvec4 mvPosition = modelViewMatrix * vec4( displacedPosition, 1.0 );\n#else\nvec4 worldPosition = modelMatrix * vec4( position, 1.0 );\nvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\nvViewPosition = -mvPosition.xyz;\nvec3 normalTex = texture2D( tNormal, uvBase ).xyz * 2.0 - 1.0;\nvNormal = normalMatrix * normalTex;\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n\n\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif\n}","fragmentShader":"uniform vec3 diffuse;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\nuniform bool enableDiffuse1;\nuniform bool enableDiffuse2;\nuniform bool enableSpecular;\nuniform sampler2D tDiffuse1;\nuniform sampler2D tDiffuse2;\nuniform sampler2D tDetail;\nuniform sampler2D tNormal;\nuniform sampler2D tSpecular;\nuniform sampler2D tDisplacement;\nuniform float uNormalScale;\nuniform vec2 uRepeatOverlay;\nuniform vec2 uRepeatBase;\nuniform vec2 uOffset;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\nvarying vec2 vUv;\nvarying vec3 vViewPosition;\n#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}\n\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t}\n\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n\nuniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n\n#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n\nfloat calcLightAttenuation( float lightDistance, float cutoffDistance, float decayExponent ) {\nif ( decayExponent > 0.0 ) {\nreturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n}\nreturn 1.0;\n}\nvoid main() {\nvec3 outgoingLight = vec3( 0.0 );\nvec4 diffuseColor = vec4( diffuse, opacity );\nvec3 specularTex = vec3( 1.0 );\nvec2 uvOverlay = uRepeatOverlay * vUv + uOffset;\nvec2 uvBase = uRepeatBase * vUv;\nvec3 normalTex = texture2D( tDetail, uvOverlay ).xyz * 2.0 - 1.0;\nnormalTex.xy *= uNormalScale;\nnormalTex = normalize( normalTex );\nif( enableDiffuse1 && enableDiffuse2 ) {\nvec4 colDiffuse1 = texture2D( tDiffuse1, uvOverlay );\nvec4 colDiffuse2 = texture2D( tDiffuse2, uvOverlay );\ncolDiffuse1 = GammaToLinear( colDiffuse1, float( GAMMA_FACTOR ) );\ncolDiffuse2 = GammaToLinear( colDiffuse2, float( GAMMA_FACTOR ) );\ndiffuseColor *= mix ( colDiffuse1, colDiffuse2, 1.0 - texture2D( tDisplacement, uvBase ) );\n } else if( enableDiffuse1 ) {\ndiffuseColor *= texture2D( tDiffuse1, uvOverlay );\n} else if( enableDiffuse2 ) {\ndiffuseColor *= texture2D( tDiffuse2, uvOverlay );\n}\nif( enableSpecular )\nspecularTex = texture2D( tSpecular, uvOverlay ).xyz;\nmat3 tsb = mat3( vTangent, vBinormal, vNormal );\nvec3 finalNormal = tsb * normalTex;\nvec3 normal = normalize( finalNormal );\nvec3 viewPosition = normalize( vViewPosition );\nvec3 totalDiffuseLight = vec3( 0.0 );\nvec3 totalSpecularLight = vec3( 0.0 );\n#if NUM_POINT_LIGHTS > 0\nfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\nvec3 lVector = pointLights[ i ].position + vViewPosition.xyz;\nfloat attenuation = calcLightAttenuation( length( lVector ), pointLights[ i ].distance, pointLights[ i ].decay );\nlVector = normalize( lVector );\nvec3 pointHalfVector = normalize( lVector + viewPosition );\nfloat pointDotNormalHalf = max( dot( normal, pointHalfVector ), 0.0 );\nfloat pointDiffuseWeight = max( dot( normal, lVector ), 0.0 );\nfloat pointSpecularWeight = specularTex.r * max( pow( pointDotNormalHalf, shininess ), 0.0 );\ntotalDiffuseLight += attenuation * pointLights[ i ].color * pointDiffuseWeight;\ntotalSpecularLight += attenuation * pointLights[ i ].color * specular * pointSpecularWeight * pointDiffuseWeight;\n}\n#endif\n#if NUM_DIR_LIGHTS > 0\nvec3 dirDiffuse = vec3( 0.0 );\nvec3 dirSpecular = vec3( 0.0 );\nfor( int i = 0; i < NUM_DIR_LIGHTS; i++ ) {\nvec3 dirVector = directionalLights[ i ].direction;\nvec3 dirHalfVector = normalize( dirVector + viewPosition );\nfloat dirDotNormalHalf = max( dot( normal, dirHalfVector ), 0.0 );\nfloat dirDiffuseWeight = max( dot( normal, dirVector ), 0.0 );\nfloat dirSpecularWeight = specularTex.r * max( pow( dirDotNormalHalf, shininess ), 0.0 );\ntotalDiffuseLight += directionalLights[ i ].color * dirDiffuseWeight;\ntotalSpecularLight += directionalLights[ i ].color * specular * dirSpecularWeight * dirDiffuseWeight;\n}\n#endif\n#if NUM_HEMI_LIGHTS > 0\nvec3 hemiDiffuse  = vec3( 0.0 );\nvec3 hemiSpecular = vec3( 0.0 );\nfor( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\nvec3 lVector = hemisphereLightDirection[ i ];\nfloat dotProduct = dot( normal, lVector );\nfloat hemiDiffuseWeight = 0.5 * dotProduct + 0.5;\ntotalDiffuseLight += mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight );\nfloat hemiSpecularWeight = 0.0;\nvec3 hemiHalfVectorSky = normalize( lVector + viewPosition );\nfloat hemiDotNormalHalfSky = 0.5 * dot( normal, hemiHalfVectorSky ) + 0.5;\nhemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfSky, shininess ), 0.0 );\nvec3 lVectorGround = -lVector;\nvec3 hemiHalfVectorGround = normalize( lVectorGround + viewPosition );\nfloat hemiDotNormalHalfGround = 0.5 * dot( normal, hemiHalfVectorGround ) + 0.5;\nhemiSpecularWeight += specularTex.r * max( pow( hemiDotNormalHalfGround, shininess ), 0.0 );\ntotalSpecularLight += specular * mix( hemisphereLights[ i ].groundColor, hemisphereLights[ i ].skyColor, hemiDiffuseWeight ) * hemiSpecularWeight * hemiDiffuseWeight;\n}\n#endif\noutgoingLight += diffuseColor.xyz * ( totalDiffuseLight + ambientLightColor + totalSpecularLight );\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );\n#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n\n}"}}]}